{"title":"OWL - Optimal Wealth Lab","markdown":{"yaml":{"title":"OWL - Optimal Wealth Lab"},"headingText":"Overview","containsRefs":false,"markdown":"\n\n\nThis package is a modeling framework for exploring the sensitivity of retirement financial decisions.\nStrictly speaking, it is not a planning tool, but more an environment for exploring *what if* scenarios.\nIt provides different realizations of a financial strategy through the rigorous\nmathematical optimization of relevant decision variables. Two major objective goals can be set: either\nmaximize net spending, or after-tax bequest under various constraints.\nLook at the *Capabilities* section below for more detail.\n\nOne can certainly have a savings plan, but due to the volatility of financial investments,\nit is impossible to have a certain asset earnings plan. This does not mean one cannot make decisions.\nThese decisions need to be guided with an understanding of the sensitivity of the parameters.\nThis is exactly where this tool fits in. Given your savings capabilities and spending desires,\nit can generate different future realizations of\nyour strategy under different market assumptions, helping to better understand your financial situation.\n\n## Purpose and vision\n\nOne goal of Owl is to provide a free and open-source ecosystem that has cutting-edge optimization capabilities,\nallowing for the next generation of Python-literate retirees to experiment with their own financial future\nwhile providing a codebase where they can learn and contribute. At the same time, an intuitive and easy-to-use\nuser interface based on Streamlit allows a broad set of users to benefit from the application as it only requires basic financial knowledge.\n\nThere are and were\ngood retirement optimizers in the recent past, but the vast majority of them are either proprietary platforms\ncollecting your data, or academic papers that share the results without really sharing the details of\nthe underlying mathematical models.\nThe algorithms in Owl rely on the open-source HiGHS linear programming solver but they have also been ported and tested on\nother platforms such as Mosek and COIN-OR. The complete formulation and\ndetailed description of the underlying\nmathematical model can be found [here](papers/owl.pdf).\n\nIt is anticipated that most end users will use Owl through the graphical interface\neither at [owlplanner.streamlit.app](https://owlplanner.streamlit.app)\nor [installed](installation.qmd) on their own computer.\nThe underlying Python package can also be used directly through Python scripts or Jupyter Notebooks\nas described [here](users_guide.qmd).\n\nA separate [installation guide is available for OWL on WSL using UV](./install-uv.qmd).\n\nNot every retirement decision strategy can be framed as an easy-to-solve optimization problem.\nIn particular, if one is interested in comparing different withdrawal strategies,\n[FI Calc](https://ficalc.app) is an elegant application that addresses this need.\nIf, however, you also want to optimize spending, bequest, and Roth conversions, with\nan approach also considering Medicare and federal income tax over the next few years,\nthen Owl is definitely a tool that can help guide your decisions.\n\n## Capabilities\n\nOwl can optimize for either maximum net spending under the constraint of a given bequest (which can be zero),\nor maximize the after-tax value of a bequest under the constraint of a desired net spending profile,\nand under the assumption of a heirs marginal tax rate.\n\nRoth conversions are also considered, subject to an optional maximum conversion amount,\nand optimized to suit the goals of the selected objective function.\n\nAll calculations are indexed for inflation, which is either provided as a fixed rate,\nor through historical values, as are all other rates used for the calculations.\nThese rates can be used for backtesting different scenarios by choosing\n*historical* rates, or by choosing *historical average* rates over a historical year range,\nor what I coined \"*histochastic*\" rates which are\ngenerated using the statistical distribution of observed historical rates.\n\nPortfolios available for experimenting include assets from the S&P 500, Corporate Bonds Baa, Treasury 10-y Notes,\nand cash assets assumed to just follow inflation which is represented by the Consumer Price Index.\nOther asset classes can easily be added, but would add complexity while only providing diminishing insights.\n\nHistorical data used are from\n[Aswath Damodaran](https://pages.stern.nyu.edu/~adamodar/) at the Stern School of Business.\n\nAsset allocations are selected for the duration of the plan, and these can glide linearly\nor along a configurable s-curve over the lifespan of the individual.\n\nSpending profiles are adjusted for inflation, and so are all other indexable quantities. Proflies can be\nflat or follow a *smile* curve which is also adjustable through three simple parameters.\n\n* Available rates are from 1928 to last year and can be used to test historical performance.\n\n* Fixed rates can also be provided, as well as *histochastic* rates, which are generated using\nthe statistical characteristics (means and covariance matrix) of\na selected historical year range.\n\n* Pure *stochastic* rates can also be generated\nif the user provides means, volatility (expressed as standard deviation), and optionally\nthe correlations between the different assets return rates provided as a matrix, or a list of\nthe off-diagonal elements (see documentation for details).\n\n* Average rates calculated over a historical data period can also be chosen.\n\nMonte Carlo simulations capabilities are included and provide a probability of success and a histogram of\noutcomes. These simulations can be used for either determining the probability distribution of the\nmaximum net spending amount under\nthe constraint of a desired bequest, or the probability distribution of the maximum\nbequest under the constraint of a desired net spending amount.\n\nUnlike discrete-event\nsimulators, Owl uses an optimization algorithm for every new scenario, which results in more\ncalculations being performed. As a result, the number of cases to be considered should be kept\nto a reasonable number. For a few hundred cases, a few minutes of calculations can provide very good estimates\nand reliable probability distributions.\n\nOptimizing each solution is more representative than event-base simulators\nin the sense that optimal solutions\nwill naturally adjust to the return scenarios being considered.\nThis is more realistic as retirees would certainly re-evaluate\ntheir expectations under severe market drops or gains.\nThis optimal approach provides a net benefit over event-based simulators,\nwhich maintain a distribution strategy either fixed, or within guardrails for capturing the\nretirees' reactions to the market.\n\nBasic input parameters can be entered through the user interface\nwhile optional additional time series can be read from\nan Excel spreadsheet that contains future wages, contributions\nto savings accounts, and planned *big-ticket items* such as the purchase of a lake house,\nthe sale of a boat, large gifts, or inheritance.\n\nThree types of savings accounts are considered: taxable, tax-deferred, and tax-free,\nwhich are all tracked separately for married individuals. Asset transition to the surviving spouse\nis done according to beneficiary fractions for each type of savings account.\nTax status covers married filing jointly and single, depending on the number of individuals reported.\n\nMaturation rules for Roth contributions and conversions are implemented as constraints\nlimiting withdrawal amounts to cover Roth account balances for 5 years after the events.\nMedicare and IRMAA calculations are performed through a self-consistent loop on cash flow constraints.\nThey can also be optimized explicitly as an option, but this choice can lead to longer calculations\ndue to the use of the many additional binary variables required by the formulation.\nFuture Medicare and IRMAA values are simple projections of current values with the assumed inflation rates.\n\nOwl has a basic social security calculator that determines the actual benefits based on the individual's\nprimary insurance amount (PIA), full retirement age (FRA), and claiming age. Both\nspousal's benefits and survivor's benefits are calculated for non-complex cases.\n\n## Limitations\n\nOwl is work in progress. At the current time:\n\n* Only the US federal income tax is considered (and minimized through the optimization algorithm). Head of household filing status has not been added but can easily be.\n\n* Required minimum distributions are calculated, but tables for spouses more than 10 years apart are not included. These cases are detected and will generate an error message.\n\n* Current version has no optimization of asset allocations between individuals and/or types of savings accounts. If there is interest, that could be added in the future.\n\n* In the current implementation, social securiy is always taxed at 85%, assuming that your taxable income will be larger than 34 k$ (single) or 44 k$ (married filing jointly).\n\n* When Medicare calculations are done through a self-consistent loop,\nthe Medicare premiums are calculated after an initial solution is generated,\nand then a new solution is re-generated with these premiums as a constraint.\nIn some situations, when the income (MAGI) is near an IRMAA bracket, oscillatory solutions can arise.\nWhile the solutions generated are very close to one another, Owl will pick the smallest solution\nfor being conservative. While sometimes computationally costly,\na comparison with a full Medicare optimization should always be performed.\n\n* Part D is not included in the IRMAA calculations. Only Part B is taken into account, which is considerably more significant.\n* Future tax brackets are pure speculations derived from the little we know now and projected to the next 30 years. Your guesses are as good as mine.\n\nThe solution from an optimization algorithm has only two states: feasible and infeasible.\nTherefore, unlike event-driven simulators that can tell you that your distribution strategy runs\nout of money in year 20, an optimization-based solver can only tell you that a solution does or does not\nexist for the plan being considered. Examples of infeasible solutions include requesting a bequeathed\nestate value too large for the savings assets to support, even with zero net spending basis,\nor maximizing the bequest subject to a net spending basis that is already too large for the savings\nassets to support, even with no estate being left.\n\n## Disclaimers\n\n* I am not a financial planner.\n* You make your own decisions.\n* This program comes with no guarantees.\n* Use at your own risk.\n\n","srcMarkdownNoYaml":"\n\n## Overview\n\nThis package is a modeling framework for exploring the sensitivity of retirement financial decisions.\nStrictly speaking, it is not a planning tool, but more an environment for exploring *what if* scenarios.\nIt provides different realizations of a financial strategy through the rigorous\nmathematical optimization of relevant decision variables. Two major objective goals can be set: either\nmaximize net spending, or after-tax bequest under various constraints.\nLook at the *Capabilities* section below for more detail.\n\nOne can certainly have a savings plan, but due to the volatility of financial investments,\nit is impossible to have a certain asset earnings plan. This does not mean one cannot make decisions.\nThese decisions need to be guided with an understanding of the sensitivity of the parameters.\nThis is exactly where this tool fits in. Given your savings capabilities and spending desires,\nit can generate different future realizations of\nyour strategy under different market assumptions, helping to better understand your financial situation.\n\n## Purpose and vision\n\nOne goal of Owl is to provide a free and open-source ecosystem that has cutting-edge optimization capabilities,\nallowing for the next generation of Python-literate retirees to experiment with their own financial future\nwhile providing a codebase where they can learn and contribute. At the same time, an intuitive and easy-to-use\nuser interface based on Streamlit allows a broad set of users to benefit from the application as it only requires basic financial knowledge.\n\nThere are and were\ngood retirement optimizers in the recent past, but the vast majority of them are either proprietary platforms\ncollecting your data, or academic papers that share the results without really sharing the details of\nthe underlying mathematical models.\nThe algorithms in Owl rely on the open-source HiGHS linear programming solver but they have also been ported and tested on\nother platforms such as Mosek and COIN-OR. The complete formulation and\ndetailed description of the underlying\nmathematical model can be found [here](papers/owl.pdf).\n\nIt is anticipated that most end users will use Owl through the graphical interface\neither at [owlplanner.streamlit.app](https://owlplanner.streamlit.app)\nor [installed](installation.qmd) on their own computer.\nThe underlying Python package can also be used directly through Python scripts or Jupyter Notebooks\nas described [here](users_guide.qmd).\n\nA separate [installation guide is available for OWL on WSL using UV](./install-uv.qmd).\n\nNot every retirement decision strategy can be framed as an easy-to-solve optimization problem.\nIn particular, if one is interested in comparing different withdrawal strategies,\n[FI Calc](https://ficalc.app) is an elegant application that addresses this need.\nIf, however, you also want to optimize spending, bequest, and Roth conversions, with\nan approach also considering Medicare and federal income tax over the next few years,\nthen Owl is definitely a tool that can help guide your decisions.\n\n## Capabilities\n\nOwl can optimize for either maximum net spending under the constraint of a given bequest (which can be zero),\nor maximize the after-tax value of a bequest under the constraint of a desired net spending profile,\nand under the assumption of a heirs marginal tax rate.\n\nRoth conversions are also considered, subject to an optional maximum conversion amount,\nand optimized to suit the goals of the selected objective function.\n\nAll calculations are indexed for inflation, which is either provided as a fixed rate,\nor through historical values, as are all other rates used for the calculations.\nThese rates can be used for backtesting different scenarios by choosing\n*historical* rates, or by choosing *historical average* rates over a historical year range,\nor what I coined \"*histochastic*\" rates which are\ngenerated using the statistical distribution of observed historical rates.\n\nPortfolios available for experimenting include assets from the S&P 500, Corporate Bonds Baa, Treasury 10-y Notes,\nand cash assets assumed to just follow inflation which is represented by the Consumer Price Index.\nOther asset classes can easily be added, but would add complexity while only providing diminishing insights.\n\nHistorical data used are from\n[Aswath Damodaran](https://pages.stern.nyu.edu/~adamodar/) at the Stern School of Business.\n\nAsset allocations are selected for the duration of the plan, and these can glide linearly\nor along a configurable s-curve over the lifespan of the individual.\n\nSpending profiles are adjusted for inflation, and so are all other indexable quantities. Proflies can be\nflat or follow a *smile* curve which is also adjustable through three simple parameters.\n\n* Available rates are from 1928 to last year and can be used to test historical performance.\n\n* Fixed rates can also be provided, as well as *histochastic* rates, which are generated using\nthe statistical characteristics (means and covariance matrix) of\na selected historical year range.\n\n* Pure *stochastic* rates can also be generated\nif the user provides means, volatility (expressed as standard deviation), and optionally\nthe correlations between the different assets return rates provided as a matrix, or a list of\nthe off-diagonal elements (see documentation for details).\n\n* Average rates calculated over a historical data period can also be chosen.\n\nMonte Carlo simulations capabilities are included and provide a probability of success and a histogram of\noutcomes. These simulations can be used for either determining the probability distribution of the\nmaximum net spending amount under\nthe constraint of a desired bequest, or the probability distribution of the maximum\nbequest under the constraint of a desired net spending amount.\n\nUnlike discrete-event\nsimulators, Owl uses an optimization algorithm for every new scenario, which results in more\ncalculations being performed. As a result, the number of cases to be considered should be kept\nto a reasonable number. For a few hundred cases, a few minutes of calculations can provide very good estimates\nand reliable probability distributions.\n\nOptimizing each solution is more representative than event-base simulators\nin the sense that optimal solutions\nwill naturally adjust to the return scenarios being considered.\nThis is more realistic as retirees would certainly re-evaluate\ntheir expectations under severe market drops or gains.\nThis optimal approach provides a net benefit over event-based simulators,\nwhich maintain a distribution strategy either fixed, or within guardrails for capturing the\nretirees' reactions to the market.\n\nBasic input parameters can be entered through the user interface\nwhile optional additional time series can be read from\nan Excel spreadsheet that contains future wages, contributions\nto savings accounts, and planned *big-ticket items* such as the purchase of a lake house,\nthe sale of a boat, large gifts, or inheritance.\n\nThree types of savings accounts are considered: taxable, tax-deferred, and tax-free,\nwhich are all tracked separately for married individuals. Asset transition to the surviving spouse\nis done according to beneficiary fractions for each type of savings account.\nTax status covers married filing jointly and single, depending on the number of individuals reported.\n\nMaturation rules for Roth contributions and conversions are implemented as constraints\nlimiting withdrawal amounts to cover Roth account balances for 5 years after the events.\nMedicare and IRMAA calculations are performed through a self-consistent loop on cash flow constraints.\nThey can also be optimized explicitly as an option, but this choice can lead to longer calculations\ndue to the use of the many additional binary variables required by the formulation.\nFuture Medicare and IRMAA values are simple projections of current values with the assumed inflation rates.\n\nOwl has a basic social security calculator that determines the actual benefits based on the individual's\nprimary insurance amount (PIA), full retirement age (FRA), and claiming age. Both\nspousal's benefits and survivor's benefits are calculated for non-complex cases.\n\n## Limitations\n\nOwl is work in progress. At the current time:\n\n* Only the US federal income tax is considered (and minimized through the optimization algorithm). Head of household filing status has not been added but can easily be.\n\n* Required minimum distributions are calculated, but tables for spouses more than 10 years apart are not included. These cases are detected and will generate an error message.\n\n* Current version has no optimization of asset allocations between individuals and/or types of savings accounts. If there is interest, that could be added in the future.\n\n* In the current implementation, social securiy is always taxed at 85%, assuming that your taxable income will be larger than 34 k$ (single) or 44 k$ (married filing jointly).\n\n* When Medicare calculations are done through a self-consistent loop,\nthe Medicare premiums are calculated after an initial solution is generated,\nand then a new solution is re-generated with these premiums as a constraint.\nIn some situations, when the income (MAGI) is near an IRMAA bracket, oscillatory solutions can arise.\nWhile the solutions generated are very close to one another, Owl will pick the smallest solution\nfor being conservative. While sometimes computationally costly,\na comparison with a full Medicare optimization should always be performed.\n\n* Part D is not included in the IRMAA calculations. Only Part B is taken into account, which is considerably more significant.\n* Future tax brackets are pure speculations derived from the little we know now and projected to the next 30 years. Your guesses are as good as mine.\n\nThe solution from an optimization algorithm has only two states: feasible and infeasible.\nTherefore, unlike event-driven simulators that can tell you that your distribution strategy runs\nout of money in year 20, an optimization-based solver can only tell you that a solution does or does not\nexist for the plan being considered. Examples of infeasible solutions include requesting a bequeathed\nestate value too large for the savings assets to support, even with zero net spending basis,\nor maximizing the bequest subject to a net spending basis that is already too large for the savings\nassets to support, even with no estate being left.\n\n## Disclaimers\n\n* I am not a financial planner.\n* You make your own decisions.\n* This program comes with no guarantees.\n* Use at your own risk.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.26","theme":"cosmo","title":"OWL - Optimal Wealth Lab"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}